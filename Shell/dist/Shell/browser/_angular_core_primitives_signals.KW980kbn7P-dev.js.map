{
  "version": 3,
  "sources": ["../../@angular/core/fesm2022/primitives/signals.mjs"],
  "sourcesContent": ["/**\n * @license Angular v20.1.7\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { consumerMarkDirty, SIGNAL, REACTIVE_NODE, consumerDestroy, isInNotificationPhase, consumerPollProducersForChange, consumerBeforeComputation, consumerAfterComputation } from '../signal.mjs';\nexport { SIGNAL_NODE, createComputed, createSignal, defaultEquals, getActiveConsumer, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn } from '../signal.mjs';\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, untracked } from '../untracked.mjs';\nexport { setAlternateWeakRefImpl } from '../weak_ref.mjs';\n\nfunction createWatch(fn, schedule, allowSignalWrites) {\n    const node = Object.create(WATCH_NODE);\n    if (allowSignalWrites) {\n        node.consumerAllowSignalWrites = true;\n    }\n    node.fn = fn;\n    node.schedule = schedule;\n    const registerOnCleanup = (cleanupFn) => {\n        node.cleanupFn = cleanupFn;\n    };\n    function isWatchNodeDestroyed(node) {\n        return node.fn === null && node.schedule === null;\n    }\n    function destroyWatchNode(node) {\n        if (!isWatchNodeDestroyed(node)) {\n            consumerDestroy(node); // disconnect watcher from the reactive graph\n            node.cleanupFn();\n            // nullify references to the integration functions to mark node as destroyed\n            node.fn = null;\n            node.schedule = null;\n            node.cleanupFn = NOOP_CLEANUP_FN;\n        }\n    }\n    const run = () => {\n        if (node.fn === null) {\n            // trying to run a destroyed watch is noop\n            return;\n        }\n        if (isInNotificationPhase()) {\n            throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n                ? 'Schedulers cannot synchronously execute watches while scheduling.'\n                : '');\n        }\n        node.dirty = false;\n        if (node.hasRun && !consumerPollProducersForChange(node)) {\n            return;\n        }\n        node.hasRun = true;\n        const prevConsumer = consumerBeforeComputation(node);\n        try {\n            node.cleanupFn();\n            node.cleanupFn = NOOP_CLEANUP_FN;\n            node.fn(registerOnCleanup);\n        }\n        finally {\n            consumerAfterComputation(node, prevConsumer);\n        }\n    };\n    node.ref = {\n        notify: () => consumerMarkDirty(node),\n        run,\n        cleanup: () => node.cleanupFn(),\n        destroy: () => destroyWatchNode(node),\n        [SIGNAL]: node,\n    };\n    return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => { };\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        consumerIsAlwaysLive: true,\n        consumerAllowSignalWrites: false,\n        consumerMarkedDirty: (node) => {\n            if (node.schedule !== null) {\n                node.schedule(node.ref);\n            }\n        },\n        hasRun: false,\n        cleanupFn: NOOP_CLEANUP_FN,\n    };\n})();\n\nexport { REACTIVE_NODE, SIGNAL, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createWatch, isInNotificationPhase };\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA,SAAS,YAAY,IAAI,UAAU,mBAAmB;AAClD,QAAM,OAAO,OAAO,OAAO,UAAU;AACrC,MAAI,mBAAmB;AACnB,SAAK,4BAA4B;AAAA,EACrC;AACA,OAAK,KAAK;AACV,OAAK,WAAW;AAChB,QAAM,oBAAoB,CAAC,cAAc;AACrC,SAAK,YAAY;AAAA,EACrB;AACA,WAAS,qBAAqBA,OAAM;AAChC,WAAOA,MAAK,OAAO,QAAQA,MAAK,aAAa;AAAA,EACjD;AACA,WAAS,iBAAiBA,OAAM;AAC5B,QAAI,CAAC,qBAAqBA,KAAI,GAAG;AAC7B,sBAAgBA,KAAI;AACpB,MAAAA,MAAK,UAAU;AAEf,MAAAA,MAAK,KAAK;AACV,MAAAA,MAAK,WAAW;AAChB,MAAAA,MAAK,YAAY;AAAA,IACrB;AAAA,EACJ;AACA,QAAM,MAAM,MAAM;AACd,QAAI,KAAK,OAAO,MAAM;AAElB;AAAA,IACJ;AACA,QAAI,sBAAsB,GAAG;AACzB,YAAM,IAAI,MAAM,OAAO,cAAc,eAAe,YAC9C,sEACA,EAAE;AAAA,IACZ;AACA,SAAK,QAAQ;AACb,QAAI,KAAK,UAAU,CAAC,+BAA+B,IAAI,GAAG;AACtD;AAAA,IACJ;AACA,SAAK,SAAS;AACd,UAAM,eAAe,0BAA0B,IAAI;AACnD,QAAI;AACA,WAAK,UAAU;AACf,WAAK,YAAY;AACjB,WAAK,GAAG,iBAAiB;AAAA,IAC7B,UACA;AACI,+BAAyB,MAAM,YAAY;AAAA,IAC/C;AAAA,EACJ;AACA,OAAK,MAAM;AAAA,IACP,QAAQ,MAAM,kBAAkB,IAAI;AAAA,IACpC;AAAA,IACA,SAAS,MAAM,KAAK,UAAU;AAAA,IAC9B,SAAS,MAAM,iBAAiB,IAAI;AAAA,IACpC,CAAC,MAAM,GAAG;AAAA,EACd;AACA,SAAO,KAAK;AAChB;AACA,IAAM,kBAAkB,MAAM;AAAE;AAIhC,IAAM,aAA8B,uBAAM;AACtC,SAAO,iCACA,gBADA;AAAA,IAEH,sBAAsB;AAAA,IACtB,2BAA2B;AAAA,IAC3B,qBAAqB,CAAC,SAAS;AAC3B,UAAI,KAAK,aAAa,MAAM;AACxB,aAAK,SAAS,KAAK,GAAG;AAAA,MAC1B;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,WAAW;AAAA,EACf;AACJ,GAAG;",
  "names": ["node"]
}
